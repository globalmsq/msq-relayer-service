{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 모노레포 구조 및 Docker Compose 인프라 설정",
        "description": "OZ Relayer v1.3.0 + Redis + MySQL을 포함한 Docker Compose 기반 개발 환경과 NestJS 모노레포 구조를 구축합니다.",
        "details": "## 구현 세부사항\n\n### 1. 디렉토리 구조 생성\n```\nmsq-relayer-service/\n├── packages/\n│   ├── api-gateway/     # NestJS 10.x\n│   ├── sdk/             # Client SDK\n│   ├── contracts/       # Hardhat\n│   └── examples/        # 통합 예제\n├── config/\n│   ├── oz-relayer/\n│   │   └── relayer-1/config.json\n│   └── relayer-pool.yaml\n├── keys/                # gitignore\n├── docker-compose.yml\n└── .env.example\n```\n\n### 2. Docker Compose 서비스 정의\n- **oz-relayer-1**: `ghcr.io/openzeppelin/openzeppelin-relayer:v1.3.0`\n  - Ports: 8080:8080, 8081:8081\n  - Volumes: ./config/oz-relayer/relayer-1:/app/config, ./keys/relayer-1:/app/config/keys\n- **redis**: `redis:7-alpine` (Port 6379)\n- **mysql**: `mysql:8.0` (Port 3306)\n- **vault**: `hashicorp/vault:1.15` (Port 8200) - dev mode\n\n### 3. OZ Relayer config.json 예시\n```json\n{\n  \"relayers\": [{\n    \"id\": \"polygon-amoy-relayer-1\",\n    \"name\": \"Polygon Amoy Relayer #1\",\n    \"network\": \"amoy\",\n    \"signer\": {\n      \"type\": \"local\",\n      \"keystore\": \"/app/config/keys/keystore.json\"\n    },\n    \"rpc\": {\n      \"url\": \"${AMOY_RPC_URL}\",\n      \"timeout\": 30000\n    },\n    \"policies\": {\n      \"gas_price_cap\": \"500000000000\",\n      \"min_balance\": \"100000000000000000\"\n    },\n    \"notifications\": [{\n      \"type\": \"webhook\",\n      \"url\": \"http://api-gateway:3000/api/v1/webhook/relayer\"\n    }]\n  }]\n}\n```\n\n### 4. 환경 변수 (.env.example)\n- AMOY_RPC_URL, POLYGON_RPC_URL\n- OZ_RELAYER_API_KEY, KEYSTORE_PASSPHRASE\n- DB_PASSWORD, DB_ROOT_PASSWORD\n- VAULT_TOKEN, WEBHOOK_SIGNING_KEY",
        "testStrategy": "1. `docker compose up -d` 실행 후 모든 서비스 healthy 상태 확인\n2. `curl http://localhost:8080/api/v1/health` - OZ Relayer health check\n3. Redis 연결 테스트: `redis-cli ping`\n4. MySQL 연결 테스트: `mysql -u relayer -p`\n5. 각 컨테이너 로그에 에러 없음 확인",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "NestJS API Gateway 프로젝트 스캐폴드 및 기본 모듈 구성",
        "description": "NestJS 10.x 기반 API Gateway 프로젝트를 생성하고, 핵심 모듈(Auth, Relay, Webhook, OZ-Relayer)의 기본 구조를 설정합니다.",
        "details": "## 구현 세부사항\n\n### 1. NestJS 프로젝트 생성\n```bash\ncd packages/api-gateway\nnpx @nestjs/cli new . --skip-git --package-manager npm\n```\n\n### 2. 필수 의존성 설치\n```json\n{\n  \"dependencies\": {\n    \"@nestjs/common\": \"^10.0.0\",\n    \"@nestjs/core\": \"^10.0.0\",\n    \"@nestjs/config\": \"^3.0.0\",\n    \"@nestjs/swagger\": \"^7.0.0\",\n    \"@prisma/client\": \"^5.0.0\",\n    \"ethers\": \"^6.0.0\",\n    \"class-validator\": \"^0.14.0\",\n    \"class-transformer\": \"^0.5.0\",\n    \"ioredis\": \"^5.0.0\",\n    \"helmet\": \"^7.0.0\"\n  }\n}\n```\n\n### 3. 모듈 구조 생성\n```\nsrc/\n├── auth/              # API Key 인증\n│   ├── auth.module.ts\n│   ├── auth.guard.ts\n│   └── api-key.service.ts\n├── relay/             # TX 엔드포인트\n│   ├── relay.module.ts\n│   ├── direct/\n│   ├── gasless/\n│   └── status/\n├── webhook/           # OZ Relayer Webhook\n│   └── webhook.module.ts\n├── oz-relayer/        # OZ Relayer 클라이언트\n│   ├── oz-relayer.module.ts\n│   └── oz-relayer.service.ts\n├── common/\n│   ├── filters/exception.filter.ts\n│   ├── interceptors/logging.interceptor.ts\n│   └── decorators/\n├── config/\n│   └── configuration.ts\n└── main.ts\n```\n\n### 4. Swagger/OpenAPI 설정\n```typescript\n// main.ts\nconst config = new DocumentBuilder()\n  .setTitle('MSQ Relayer API')\n  .setVersion('1.0')\n  .addApiKey({ type: 'apiKey', name: 'X-API-Key', in: 'header' })\n  .build();\nconst document = SwaggerModule.createDocument(app, config);\nSwaggerModule.setup('api', app, document);\n```\n\n### 5. Dockerfile 생성 (packages/api-gateway/Dockerfile)\n```dockerfile\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nCMD [\"node\", \"dist/main.js\"]\n```",
        "testStrategy": "1. `npm run start:dev` - 서버 정상 시작 확인\n2. `curl http://localhost:3000/api` - Swagger UI 접근 확인\n3. 모든 모듈 DI 컨테이너 정상 로드 확인\n4. `npm run lint` - 린트 에러 없음\n5. `npm run build` - 빌드 성공 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "API Key 인증 모듈 및 Guard 구현",
        "description": "NestJS Guard 기반 API Key 인증 시스템을 구현하고, 환경 변수 또는 DB 기반 API Key 검증 로직을 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. API Key Guard 구현\n```typescript\n// auth/auth.guard.ts\n@Injectable()\nexport class ApiKeyGuard implements CanActivate {\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly reflector: Reflector,\n  ) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const isPublic = this.reflector.getAllAndOverride<boolean>('isPublic', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) return true;\n\n    const request = context.switchToHttp().getRequest();\n    const apiKey = request.headers['x-api-key'];\n    \n    if (!apiKey) {\n      throw new UnauthorizedException('API Key is required');\n    }\n    \n    return this.validateApiKey(apiKey);\n  }\n\n  private validateApiKey(apiKey: string): boolean {\n    const validKeys = this.configService.get<string>('API_KEYS')?.split(',') || [];\n    return validKeys.includes(apiKey);\n  }\n}\n```\n\n### 2. Public 데코레이터\n```typescript\n// common/decorators/public.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\n```\n\n### 3. Global Guard 등록\n```typescript\n// auth/auth.module.ts\n@Module({\n  providers: [\n    ApiKeyService,\n    {\n      provide: APP_GUARD,\n      useClass: ApiKeyGuard,\n    },\n  ],\n  exports: [ApiKeyService],\n})\nexport class AuthModule {}\n```\n\n### 4. DTO 정의\n```typescript\n// common/dto/api-response.dto.ts\nexport class ApiResponse<T> {\n  @ApiProperty()\n  success: boolean;\n\n  @ApiPropertyOptional()\n  data?: T;\n\n  @ApiPropertyOptional()\n  error?: string;\n}\n```\n\n### 5. Rate Limiting 기본 설정 (Phase 2 준비)\n```typescript\n// @nestjs/throttler 설치 및 기본 설정\nThrottlerModule.forRoot([{\n  ttl: 60000,\n  limit: 100,\n}])\n```",
        "testStrategy": "1. API Key 없이 요청 시 401 Unauthorized 응답 확인\n2. 잘못된 API Key로 요청 시 401 응답 확인\n3. 올바른 API Key로 요청 시 정상 응답 확인\n4. @Public() 데코레이터 적용 엔드포인트는 인증 없이 접근 가능 확인\n5. Rate Limiting 동작 확인 (100 req/min 초과 시 429 응답)",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Health Check 엔드포인트 구현",
        "description": "API Gateway, OZ Relayer, Redis, MySQL 상태를 확인하는 Health Check API를 구현합니다.",
        "details": "## 구현 세부사항\n\n### 1. @nestjs/terminus 설치\n```bash\nnpm install @nestjs/terminus\n```\n\n### 2. Health Controller 구현\n```typescript\n// health/health.controller.ts\n@Controller('api/v1/health')\nexport class HealthController {\n  constructor(\n    private health: HealthCheckService,\n    private http: HttpHealthIndicator,\n    private db: PrismaHealthIndicator,\n    private ozRelayer: OzRelayerHealthIndicator,\n  ) {}\n\n  @Get()\n  @Public()\n  @HealthCheck()\n  async check() {\n    return this.health.check([\n      () => this.http.pingCheck('redis', 'redis://redis:6379'),\n      () => this.db.pingCheck('mysql'),\n      () => this.ozRelayer.isHealthy('oz-relayer'),\n    ]);\n  }\n}\n```\n\n### 3. OZ Relayer Health Indicator\n```typescript\n// health/oz-relayer.health.ts\n@Injectable()\nexport class OzRelayerHealthIndicator extends HealthIndicator {\n  constructor(private readonly httpService: HttpService) {\n    super();\n  }\n\n  async isHealthy(key: string): Promise<HealthIndicatorResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('http://oz-relayer:8080/api/v1/health')\n      );\n      const isHealthy = response.status === 200;\n      return this.getStatus(key, isHealthy, { status: response.data });\n    } catch (error) {\n      return this.getStatus(key, false, { error: error.message });\n    }\n  }\n}\n```\n\n### 4. 응답 형식\n```json\n{\n  \"status\": \"ok\",\n  \"info\": {\n    \"api-gateway\": { \"status\": \"up\" },\n    \"oz-relayer\": { \"status\": \"up\" },\n    \"redis\": { \"status\": \"up\" },\n    \"mysql\": { \"status\": \"up\" }\n  },\n  \"error\": {},\n  \"details\": { ... }\n}\n```",
        "testStrategy": "1. `GET /api/v1/health` - 모든 서비스 healthy 시 200 OK 반환\n2. OZ Relayer 다운 시 degraded 상태 반환\n3. Redis 연결 실패 시 에러 상세 정보 포함\n4. MySQL 연결 실패 시 에러 상세 정보 포함\n5. 각 서비스별 개별 상태 정보 확인",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "OZ Relayer 프록시 서비스 및 Multi-Relayer Pool 관리자 구현",
        "description": "OZ Relayer SDK 래퍼 서비스를 구현하고, Multi-Relayer Pool에서 Load Balancing(Round Robin/Least Load) 및 Health Check 로직을 구현합니다.",
        "details": "## 구현 세부사항\n\n### 1. relayer-pool.yaml 설정\n```yaml\nrelayer_pool:\n  strategy: \"round_robin\"  # round_robin | least_load\n  health_check:\n    interval_ms: 10000\n    timeout_ms: 5000\n    unhealthy_threshold: 3\n  relayers:\n    - id: \"relayer-1\"\n      url: \"http://oz-relayer-1:8080\"\n      api_key: \"${OZ_RELAYER_1_API_KEY}\"\n      priority: 1\n```\n\n### 2. Relayer Pool Service\n```typescript\n// oz-relayer/relayer-pool.service.ts\n@Injectable()\nexport class RelayerPoolService {\n  private relayers: RelayerInstance[] = [];\n  private currentIndex = 0;\n\n  async getHealthyRelayer(): Promise<RelayerInstance> {\n    const healthy = this.relayers.filter(r => r.isHealthy);\n    if (healthy.length === 0) {\n      throw new ServiceUnavailableException('No healthy relayers available');\n    }\n    \n    if (this.strategy === 'round_robin') {\n      return this.roundRobinSelect(healthy);\n    }\n    return this.leastLoadSelect(healthy);\n  }\n\n  private roundRobinSelect(relayers: RelayerInstance[]): RelayerInstance {\n    const relayer = relayers[this.currentIndex % relayers.length];\n    this.currentIndex++;\n    return relayer;\n  }\n\n  private leastLoadSelect(relayers: RelayerInstance[]): RelayerInstance {\n    return relayers.reduce((min, r) => \n      r.pendingTxCount < min.pendingTxCount ? r : min\n    );\n  }\n}\n```\n\n### 3. OZ Relayer Client Service\n```typescript\n// oz-relayer/oz-relayer.service.ts\n@Injectable()\nexport class OzRelayerService {\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly poolService: RelayerPoolService,\n  ) {}\n\n  async sendTransaction(request: DirectTxRequest): Promise<TxResponse> {\n    const relayer = await this.poolService.getHealthyRelayer();\n    const response = await firstValueFrom(\n      this.httpService.post(\n        `${relayer.url}/api/v1/relayers/${relayer.id}/transactions`,\n        request,\n        { headers: { 'Authorization': `Bearer ${relayer.apiKey}` } }\n      )\n    );\n    return response.data;\n  }\n\n  async getTransactionStatus(txId: string): Promise<TxStatus> {\n    // 모든 relayer에서 조회 시도\n  }\n}\n```\n\n### 4. Health Check Scheduler\n```typescript\n@Injectable()\nexport class RelayerHealthScheduler {\n  @Cron('*/10 * * * * *')  // 10초마다\n  async checkRelayerHealth() {\n    for (const relayer of this.relayers) {\n      try {\n        const response = await this.httpService.get(\n          `${relayer.url}/api/v1/health`,\n          { timeout: 5000 }\n        );\n        relayer.isHealthy = response.status === 200;\n        relayer.failCount = 0;\n      } catch {\n        relayer.failCount++;\n        if (relayer.failCount >= 3) {\n          relayer.isHealthy = false;\n        }\n      }\n    }\n  }\n}\n```",
        "testStrategy": "1. Round Robin 전략: 순차적으로 다른 Relayer 선택 확인\n2. Least Load 전략: 대기 TX 가장 적은 Relayer 선택 확인\n3. Relayer 다운 시 자동으로 다른 Relayer로 전환 확인\n4. 모든 Relayer 다운 시 503 Service Unavailable 반환\n5. Health Check 스케줄러 정상 동작 확인",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Direct Transaction API 엔드포인트 구현",
        "description": "POST /api/v1/relay/direct 엔드포인트를 구현하여 OZ Relayer를 통한 Direct Transaction 전송 기능을 제공합니다.",
        "details": "## 구현 세부사항\n\n### 1. DTO 정의\n```typescript\n// relay/direct/dto/direct-tx.dto.ts\nexport class DirectTxRequestDto {\n  @ApiProperty({ description: '대상 컨트랙트 주소' })\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty({ description: 'Encoded function call' })\n  @IsHexadecimal()\n  data: string;\n\n  @ApiPropertyOptional({ description: 'ETH 전송량 (wei)' })\n  @IsOptional()\n  @IsNumberString()\n  value?: string;\n\n  @ApiPropertyOptional({ enum: ['safeLow', 'average', 'fast', 'fastest'] })\n  @IsOptional()\n  @IsIn(['safeLow', 'average', 'fast', 'fastest'])\n  speed?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsNumber()\n  gasLimit?: number;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  metadata?: Record<string, any>;\n}\n\nexport class DirectTxResponseDto {\n  @ApiProperty()\n  txId: string;\n\n  @ApiProperty()\n  txHash: string;\n\n  @ApiProperty({ enum: ['pending', 'sent', 'submitted', 'inmempool', 'mined', 'confirmed', 'failed'] })\n  status: string;\n\n  @ApiProperty()\n  from: string;\n\n  @ApiProperty()\n  nonce: number;\n\n  @ApiPropertyOptional()\n  gasPrice?: string;\n}\n```\n\n### 2. Controller 구현\n```typescript\n// relay/direct/direct.controller.ts\n@Controller('api/v1/relay')\n@ApiTags('Relay')\nexport class DirectController {\n  constructor(private readonly directService: DirectService) {}\n\n  @Post('direct')\n  @ApiOperation({ summary: 'Direct Transaction 전송' })\n  @ApiResponse({ status: 201, type: DirectTxResponseDto })\n  async sendDirectTransaction(\n    @Body() dto: DirectTxRequestDto,\n  ): Promise<ApiResponse<DirectTxResponseDto>> {\n    const result = await this.directService.send(dto);\n    return { success: true, data: result };\n  }\n}\n```\n\n### 3. Service 구현\n```typescript\n// relay/direct/direct.service.ts\n@Injectable()\nexport class DirectService {\n  constructor(private readonly ozRelayer: OzRelayerService) {}\n\n  async send(dto: DirectTxRequestDto): Promise<DirectTxResponseDto> {\n    const txRequest = {\n      to: dto.to,\n      data: dto.data,\n      value: dto.value || '0',\n      speed: dto.speed || 'average',\n      gasLimit: dto.gasLimit,\n    };\n\n    const response = await this.ozRelayer.sendTransaction(txRequest);\n    \n    return {\n      txId: response.id,\n      txHash: response.hash,\n      status: response.status,\n      from: response.from,\n      nonce: response.nonce,\n      gasPrice: response.gasPrice,\n    };\n  }\n}\n```\n\n### 4. OZ Defender SDK 호환 응답 포맷 유지",
        "testStrategy": "1. 유효한 요청으로 Direct TX 전송 성공 확인\n2. 필수 필드 누락 시 400 Bad Request 반환\n3. 잘못된 주소 형식 시 validation 에러 확인\n4. OZ Relayer 에러 시 적절한 에러 응답 반환\n5. 응답 포맷이 OZ Defender SDK와 호환되는지 확인",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Smart Contracts 패키지 및 ERC2771Forwarder 배포 스크립트 작성",
        "description": "Hardhat 기반 스마트 컨트랙트 패키지를 설정하고, OpenZeppelin ERC2771Forwarder 배포 스크립트와 Sample ERC20/ERC721 컨트랙트를 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. Hardhat 프로젝트 초기화\n```bash\ncd packages/contracts\nnpm init -y\nnpm install --save-dev hardhat @nomicfoundation/hardhat-toolbox typescript\nnpm install @openzeppelin/contracts@^5.3.0\nnpx hardhat init\n```\n\n### 2. hardhat.config.ts\n```typescript\nimport { HardhatUserConfig } from 'hardhat/config';\nimport '@nomicfoundation/hardhat-toolbox';\n\nconst config: HardhatUserConfig = {\n  solidity: {\n    version: '0.8.20',\n    settings: { optimizer: { enabled: true, runs: 200 } }\n  },\n  networks: {\n    hardhat: { chainId: 31337 },\n    amoy: {\n      url: process.env.AMOY_RPC_URL || '',\n      chainId: 80002,\n      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []\n    },\n    polygon: {\n      url: process.env.POLYGON_RPC_URL || '',\n      chainId: 137,\n      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []\n    }\n  }\n};\nexport default config;\n```\n\n### 3. Sample ERC20 + ERC2771Context\n```solidity\n// contracts/tokens/SampleToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\n\ncontract SampleToken is ERC20, ERC2771Context {\n    constructor(address trustedForwarder) \n        ERC20(\"Sample Token\", \"SAMPLE\") \n        ERC2771Context(trustedForwarder) \n    {\n        _mint(msg.sender, 1000000 * 10**18);\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Context) \n        returns (address) {\n        return ERC2771Context._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Context) \n        returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    function _contextSuffixLength() internal view override(Context, ERC2771Context) \n        returns (uint256) {\n        return ERC2771Context._contextSuffixLength();\n    }\n}\n```\n\n### 4. Forwarder 배포 스크립트\n```typescript\n// scripts/deploy-forwarder.ts\nimport { ethers } from 'hardhat';\n\nasync function main() {\n  const ERC2771Forwarder = await ethers.getContractFactory('ERC2771Forwarder');\n  const forwarder = await ERC2771Forwarder.deploy('Relayer-Forwarder');\n  await forwarder.waitForDeployment();\n  \n  console.log(`ERC2771Forwarder deployed to: ${await forwarder.getAddress()}`);\n  \n  // 배포 정보 저장\n  const deployments = {\n    network: network.name,\n    chainId: network.config.chainId,\n    forwarder: await forwarder.getAddress(),\n    deployedAt: new Date().toISOString()\n  };\n  fs.writeFileSync(\n    `./deployments/${network.name}.json`,\n    JSON.stringify(deployments, null, 2)\n  );\n}\n\nmain().catch(console.error);\n```",
        "testStrategy": "1. `npx hardhat compile` - 컴파일 성공 확인\n2. `npx hardhat test` - 로컬 테스트 통과\n3. Hardhat 로컬 노드에서 Forwarder 배포 테스트\n4. SampleToken이 Forwarder를 신뢰하는지 확인\n5. Polygon Amoy에 배포 후 컨트랙트 검증",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Gasless Transaction API 및 EIP-712 서명 검증 구현",
        "description": "POST /api/v1/relay/gasless 엔드포인트를 구현하고, ethers.js v6를 사용한 EIP-712 서명 사전 검증 로직을 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. ForwardRequest DTO\n```typescript\n// relay/gasless/dto/gasless-tx.dto.ts\nexport class ForwardRequestDto {\n  @ApiProperty()\n  @IsEthereumAddress()\n  from: string;\n\n  @ApiProperty()\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  value: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  gas: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  nonce: string;\n\n  @ApiProperty()\n  @IsNumber()\n  deadline: number;\n\n  @ApiProperty()\n  @IsHexadecimal()\n  data: string;\n}\n\nexport class GaslessTxRequestDto {\n  @ApiProperty({ type: ForwardRequestDto })\n  @ValidateNested()\n  @Type(() => ForwardRequestDto)\n  request: ForwardRequestDto;\n\n  @ApiProperty({ description: 'EIP-712 서명' })\n  @IsHexadecimal()\n  signature: string;\n\n  @ApiPropertyOptional()\n  metadata?: Record<string, any>;\n}\n```\n\n### 2. EIP-712 서명 검증 서비스\n```typescript\n// relay/gasless/signature-verifier.service.ts\nimport { verifyTypedData, TypedDataDomain } from 'ethers';\n\n@Injectable()\nexport class SignatureVerifierService {\n  private readonly domain: TypedDataDomain;\n  private readonly types = {\n    ForwardRequest: [\n      { name: 'from', type: 'address' },\n      { name: 'to', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'gas', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint48' },\n      { name: 'data', type: 'bytes' },\n    ],\n  };\n\n  constructor(private configService: ConfigService) {\n    this.domain = {\n      name: 'Relayer-Forwarder',\n      version: '1',\n      chainId: configService.get<number>('CHAIN_ID'),\n      verifyingContract: configService.get<string>('FORWARDER_ADDRESS'),\n    };\n  }\n\n  verifySignature(request: ForwardRequestDto, signature: string): boolean {\n    try {\n      const recoveredAddress = verifyTypedData(\n        this.domain,\n        this.types,\n        request,\n        signature\n      );\n      return recoveredAddress.toLowerCase() === request.from.toLowerCase();\n    } catch {\n      return false;\n    }\n  }\n\n  validateDeadline(deadline: number): boolean {\n    return deadline > Math.floor(Date.now() / 1000);\n  }\n}\n```\n\n### 3. Gasless Service\n```typescript\n// relay/gasless/gasless.service.ts\n@Injectable()\nexport class GaslessService {\n  constructor(\n    private readonly signatureVerifier: SignatureVerifierService,\n    private readonly ozRelayer: OzRelayerService,\n  ) {}\n\n  async send(dto: GaslessTxRequestDto): Promise<GaslessTxResponseDto> {\n    // 1. Deadline 검증\n    if (!this.signatureVerifier.validateDeadline(dto.request.deadline)) {\n      throw new BadRequestException('Request expired');\n    }\n\n    // 2. EIP-712 서명 검증\n    if (!this.signatureVerifier.verifySignature(dto.request, dto.signature)) {\n      throw new UnauthorizedException('Invalid signature');\n    }\n\n    // 3. Forwarder.execute() 호출용 TX 빌드\n    const forwarderTx = this.buildForwarderExecuteTx(dto);\n    \n    // 4. OZ Relayer로 전송\n    return this.ozRelayer.sendTransaction(forwarderTx);\n  }\n\n  private buildForwarderExecuteTx(dto: GaslessTxRequestDto) {\n    const iface = new Interface(ERC2771ForwarderABI);\n    const data = iface.encodeFunctionData('execute', [\n      {\n        from: dto.request.from,\n        to: dto.request.to,\n        value: dto.request.value,\n        gas: dto.request.gas,\n        nonce: dto.request.nonce,\n        deadline: dto.request.deadline,\n        data: dto.request.data,\n      },\n      dto.signature,\n    ]);\n    return { to: this.forwarderAddress, data, value: dto.request.value };\n  }\n}\n```\n\n### 4. Nonce 조회 엔드포인트\n```typescript\n@Get('nonce/:address')\nasync getNonce(@Param('address') address: string, @Query('network') network: string) {\n  const nonce = await this.gaslessService.getNonceFromForwarder(address);\n  return { address, nonce, network, forwarder: this.forwarderAddress };\n}\n```",
        "testStrategy": "1. 유효한 EIP-712 서명으로 Gasless TX 전송 성공 확인\n2. 잘못된 서명 시 401 Unauthorized 반환\n3. 만료된 deadline 시 400 Bad Request 반환\n4. from 주소와 서명자 불일치 시 에러 반환\n5. Nonce 조회 API 정상 동작 확인\n6. Forwarder contract 호출 데이터 정확성 검증",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Transaction Status 조회 API 및 Webhook 핸들러 구현",
        "description": "GET /api/v1/relay/status/{txId} 엔드포인트와 OZ Relayer Webhook 이벤트 처리 핸들러를 구현합니다.",
        "details": "## 구현 세부사항\n\n### 1. Status Controller\n```typescript\n// relay/status/status.controller.ts\n@Controller('api/v1/relay')\nexport class StatusController {\n  constructor(private readonly statusService: StatusService) {}\n\n  @Get('status/:txId')\n  @ApiOperation({ summary: '트랜잭션 상태 조회' })\n  async getStatus(@Param('txId') txId: string): Promise<ApiResponse<TxStatusDto>> {\n    const status = await this.statusService.getStatus(txId);\n    return { success: true, data: status };\n  }\n}\n```\n\n### 2. Status DTO\n```typescript\nexport class TxStatusDto {\n  @ApiProperty()\n  txId: string;\n\n  @ApiPropertyOptional()\n  txHash?: string;\n\n  @ApiProperty({ enum: ['pending', 'sent', 'submitted', 'inmempool', 'mined', 'confirmed', 'failed'] })\n  status: string;\n\n  @ApiPropertyOptional()\n  confirmations?: number;\n\n  @ApiPropertyOptional()\n  blockNumber?: number;\n\n  @ApiPropertyOptional()\n  error?: string;\n}\n```\n\n### 3. Webhook Controller\n```typescript\n// webhook/webhook.controller.ts\n@Controller('api/v1/webhook')\nexport class WebhookController {\n  constructor(private readonly webhookService: WebhookService) {}\n\n  @Post('relayer')\n  @Public()\n  async handleRelayerWebhook(\n    @Headers('x-webhook-signature') signature: string,\n    @Body() payload: RelayerWebhookPayload,\n  ) {\n    // 1. Webhook 서명 검증\n    if (!this.webhookService.verifySignature(payload, signature)) {\n      throw new UnauthorizedException('Invalid webhook signature');\n    }\n\n    // 2. 이벤트 처리\n    await this.webhookService.processEvent(payload);\n    return { received: true };\n  }\n}\n```\n\n### 4. Webhook Service\n```typescript\n@Injectable()\nexport class WebhookService {\n  constructor(\n    private readonly configService: ConfigService,\n    @InjectRepository(Transaction)\n    private readonly txRepository: Repository<Transaction>,\n  ) {}\n\n  verifySignature(payload: any, signature: string): boolean {\n    const signingKey = this.configService.get('WEBHOOK_SIGNING_KEY');\n    const expectedSig = createHmac('sha256', signingKey)\n      .update(JSON.stringify(payload))\n      .digest('hex');\n    return signature === expectedSig;\n  }\n\n  async processEvent(payload: RelayerWebhookPayload) {\n    const { event, data } = payload;\n    \n    switch (event) {\n      case 'transaction.mined':\n        await this.updateTxStatus(data.txId, 'mined', data);\n        break;\n      case 'transaction.confirmed':\n        await this.updateTxStatus(data.txId, 'confirmed', data);\n        break;\n      case 'transaction.failed':\n        await this.updateTxStatus(data.txId, 'failed', data);\n        break;\n    }\n  }\n}\n```\n\n### 5. Prisma Schema 추가\n```prisma\nmodel Transaction {\n  id            String   @id @default(uuid())\n  txId          String   @unique\n  txHash        String?\n  status        String   @default(\"pending\")\n  from          String\n  to            String\n  type          String   // \"direct\" | \"gasless\"\n  confirmations Int      @default(0)\n  blockNumber   Int?\n  error         String?\n  metadata      Json?\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n}\n```",
        "testStrategy": "1. 유효한 txId로 상태 조회 성공 확인\n2. 존재하지 않는 txId 시 404 Not Found 반환\n3. Webhook 서명 검증 성공/실패 케이스 테스트\n4. 각 이벤트 타입별 상태 업데이트 확인\n5. DB에 트랜잭션 정보 정상 저장 확인",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Client SDK 패키지 개발 (OZ Defender 호환)",
        "description": "OpenZeppelin Defender SDK와 호환되는 TypeScript Client SDK를 개발하여 Client Service의 마이그레이션 용이성을 제공합니다.",
        "details": "## 구현 세부사항\n\n### 1. SDK 프로젝트 구조\n```\npackages/sdk/\n├── src/\n│   ├── index.ts           # RelayerClient 진입점\n│   ├── clients/\n│   │   ├── relayer.ts     # Direct TX 클라이언트\n│   │   └── relay-signer.ts # Gasless TX 클라이언트\n│   ├── models/\n│   │   ├── transactions.ts\n│   │   ├── relayer.ts\n│   │   └── common.ts      # ApiResponse<T>\n│   └── types.ts\n├── package.json\n└── tsconfig.json\n```\n\n### 2. RelayerClient 진입점\n```typescript\n// src/index.ts\nexport class RelayerClient {\n  public readonly relayer: Relayer;\n  public readonly relaySigner: RelaySigner;\n\n  constructor(config: RelayerClientConfig) {\n    const httpClient = new HttpClient(config);\n    this.relayer = new Relayer(httpClient);\n    this.relaySigner = new RelaySigner(httpClient);\n  }\n}\n\nexport interface RelayerClientConfig {\n  apiKey: string;\n  apiSecret: string;\n  network: string;\n  baseUrl?: string;\n}\n```\n\n### 3. Relayer 클라이언트 (Direct TX)\n```typescript\n// src/clients/relayer.ts\nexport class Relayer {\n  constructor(private readonly http: HttpClient) {}\n\n  async sendTransaction(request: DirectTxRequest): Promise<ApiResponse<TxResponse>> {\n    return this.http.post('/relay/direct', request);\n  }\n\n  async getRelayer(): Promise<ApiResponse<RelayerInfo>> {\n    return this.http.get('/relay/info');\n  }\n\n  async getTransactionStatus(txId: string): Promise<ApiResponse<TxStatus>> {\n    return this.http.get(`/relay/status/${txId}`);\n  }\n\n  async cancelTransactionById(txId: string): Promise<ApiResponse<void>> {\n    return this.http.post(`/relay/cancel/${txId}`);\n  }\n}\n```\n\n### 4. RelaySigner 클라이언트 (Gasless TX)\n```typescript\n// src/clients/relay-signer.ts\nexport class RelaySigner {\n  async sendTransaction(request: GaslessTxRequest): Promise<ApiResponse<TxResponse>> {\n    return this.http.post('/relay/gasless', request);\n  }\n\n  async getNonce(address: string): Promise<ApiResponse<NonceInfo>> {\n    return this.http.get(`/relay/nonce/${address}`);\n  }\n}\n```\n\n### 5. ApiResponse 래퍼\n```typescript\n// src/models/common.ts\nexport interface ApiResponse<T> {\n  data: T | null;\n  error?: string;\n  success: boolean;\n}\n\nexport type TxStatus = \n  | 'pending' \n  | 'sent' \n  | 'submitted' \n  | 'inmempool' \n  | 'mined' \n  | 'confirmed' \n  | 'failed';\n```\n\n### 6. package.json\n```json\n{\n  \"name\": \"@msq/relayer-sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"dependencies\": {\n    \"ethers\": \"^6.0.0\"\n  },\n  \"peerDependencies\": {\n    \"ethers\": \"^6.0.0\"\n  }\n}\n```",
        "testStrategy": "1. Direct TX 전송 테스트 (sendTransaction)\n2. Gasless TX 전송 테스트 (relaySigner.sendTransaction)\n3. 트랜잭션 상태 조회 테스트\n4. Nonce 조회 테스트\n5. API 에러 응답 처리 테스트\n6. OZ Defender SDK에서 마이그레이션 코드 변경 최소화 확인",
        "priority": "medium",
        "dependencies": [
          6,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "통합 테스트 및 결제 시스템 연동 검증",
        "description": "전체 시스템 통합 테스트를 수행하고, 결제 시스템 연동 시나리오(Direct TX 정산, Gasless TX 가스비 대납)를 검증합니다.",
        "details": "## 구현 세부사항\n\n### 1. E2E 테스트 설정\n```typescript\n// packages/api-gateway/test/e2e/relay.e2e-spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\n\ndescribe('Relay API (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  describe('Direct Transaction', () => {\n    it('should send direct transaction successfully', async () => {\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/direct')\n        .set('X-API-Key', process.env.TEST_API_KEY)\n        .send({\n          to: '0x...',\n          data: '0x...',\n          value: '0',\n          speed: 'fast',\n        })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.txId).toBeDefined();\n    });\n  });\n\n  describe('Gasless Transaction', () => {\n    it('should send gasless transaction with valid signature', async () => {\n      const forwardRequest = await buildForwardRequest();\n      const signature = await signTypedData(forwardRequest);\n\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/gasless')\n        .set('X-API-Key', process.env.TEST_API_KEY)\n        .send({ request: forwardRequest, signature })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n    });\n  });\n});\n```\n\n### 2. 결제 시스템 시나리오 테스트\n```typescript\n// packages/examples/src/integration/payment-system.test.ts\ndescribe('Payment System Integration', () => {\n  describe('Direct TX - 토큰 정산', () => {\n    it('should batch transfer tokens to multiple recipients', async () => {\n      const recipients = [\n        { address: '0x...', amount: '100' },\n        { address: '0x...', amount: '200' },\n      ];\n\n      for (const recipient of recipients) {\n        const tx = await client.relayer.sendTransaction({\n          to: TOKEN_ADDRESS,\n          data: encodeTransfer(recipient.address, recipient.amount),\n        });\n        expect(tx.data.status).toBe('submitted');\n      }\n    });\n  });\n\n  describe('Gasless TX - 가스비 대납 결제', () => {\n    it('should execute payment on behalf of end user', async () => {\n      // 1. End User 서명 시뮬레이션\n      const userWallet = new Wallet(USER_PRIVATE_KEY);\n      const nonce = await client.relaySigner.getNonce(userWallet.address);\n      \n      const forwardRequest = {\n        from: userWallet.address,\n        to: TOKEN_ADDRESS,\n        value: '0',\n        gas: '200000',\n        nonce: nonce.data.nonce,\n        deadline: Math.floor(Date.now() / 1000) + 3600,\n        data: encodeTransfer(MERCHANT_ADDRESS, '50'),\n      };\n\n      const signature = await userWallet.signTypedData(domain, types, forwardRequest);\n\n      // 2. Client Service가 Relayer API 호출\n      const tx = await client.relaySigner.sendTransaction({\n        request: forwardRequest,\n        signature,\n        metadata: { paymentId: 'PAY-001', userId: userWallet.address },\n      });\n\n      expect(tx.data.status).toBe('submitted');\n\n      // 3. 상태 확인\n      await waitForConfirmation(tx.data.txId);\n    });\n  });\n});\n```\n\n### 3. 부하 테스트 (Artillery)\n```yaml\n# load-test.yml\nconfig:\n  target: 'http://localhost:3000'\n  phases:\n    - duration: 60\n      arrivalRate: 10\n  defaults:\n    headers:\n      X-API-Key: '{{API_KEY}}'\n\nscenarios:\n  - name: 'Direct TX Load Test'\n    flow:\n      - post:\n          url: '/api/v1/relay/direct'\n          json:\n            to: '0x...'\n            data: '0x...'\n```",
        "testStrategy": "1. 로컬 Hardhat 노드에서 전체 플로우 테스트\n2. Polygon Amoy에서 실제 트랜잭션 테스트\n3. Direct TX 배치 처리 성능 테스트 (100 TX)\n4. Gasless TX End-to-End 플로우 검증\n5. Multi-Relayer Pool 부하 분산 테스트\n6. 에러 시나리오 테스트 (Relayer 다운, 잔액 부족 등)",
        "priority": "high",
        "dependencies": [
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "프로덕션 환경 설정, API 문서화 및 운영 가이드 작성",
        "description": "프로덕션 배포를 위한 환경 설정, Swagger 기반 API 문서화, 운영 가이드 및 트러블슈팅 문서를 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. 프로덕션 Docker Compose\n```yaml\n# docker-compose.prod.yml\nversion: '3.8'\n\nservices:\n  api-gateway:\n    image: msq-relayer/api-gateway:${VERSION}\n    deploy:\n      replicas: 2\n      resources:\n        limits:\n          cpus: '1'\n          memory: 1G\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=${DATABASE_URL}\n    healthcheck:\n      test: ['CMD', 'curl', '-f', 'http://localhost:3000/api/v1/health']\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  oz-relayer-1:\n    image: ghcr.io/openzeppelin/openzeppelin-relayer:v1.3.0\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 512M\n    secrets:\n      - keystore_passphrase\n```\n\n### 2. Swagger 문서 완성\n```typescript\n// 모든 엔드포인트에 상세 문서 추가\n@ApiOperation({\n  summary: 'Direct Transaction 전송',\n  description: `\n    OZ Relayer를 통해 Direct Transaction을 전송합니다.\n    \n    ## 사용 사례\n    - 결제 시스템 토큰 정산\n    - 에어드랍 배치 처리\n    \n    ## 주의사항\n    - gasLimit 미지정 시 자동 추정\n    - speed에 따라 가스 가격 조정\n  `,\n})\n@ApiResponse({\n  status: 201,\n  description: '트랜잭션 전송 성공',\n  type: DirectTxResponseDto,\n})\n@ApiResponse({\n  status: 400,\n  description: '잘못된 요청 파라미터',\n})\n@ApiResponse({\n  status: 503,\n  description: 'OZ Relayer 연결 실패',\n})\n```\n\n### 3. 운영 가이드 (docs/operations.md)\n```markdown\n# MSQ Relayer 운영 가이드\n\n## 1. 서비스 시작/종료\n```bash\n# 시작\ndocker compose -f docker-compose.prod.yml up -d\n\n# 종료\ndocker compose -f docker-compose.prod.yml down\n```\n\n## 2. Relayer 잔액 모니터링\n- OZ Monitor 알림 설정 확인\n- 최소 잔액: 0.1 MATIC (Polygon)\n\n## 3. 스케일링\n```bash\n# Relayer 추가\ndocker compose --profile scale up -d oz-relayer-2\n```\n\n## 4. 트러블슈팅\n### 4.1 Nonce 충돌\n- OZ Relayer 자동 복구 대기 (최대 5분)\n- 수동 개입: Relayer 재시작\n\n### 4.2 Gas Price 급등\n- gas_price_cap 확인\n- 필요시 상한 조정 후 Relayer 재시작\n```\n\n### 4. 배포 Makefile\n```makefile\n.PHONY: build deploy\n\nbuild:\n\tdocker build -t msq-relayer/api-gateway:$(VERSION) ./packages/api-gateway\n\ndeploy-staging:\n\tdocker compose -f docker-compose.staging.yml up -d\n\ndeploy-prod:\n\tdocker compose -f docker-compose.prod.yml up -d\n\nlogs:\n\tdocker compose logs -f api-gateway oz-relayer-1\n\nhealth:\n\tcurl http://localhost:3000/api/v1/health | jq\n```\n\n### 5. 환경별 설정 분리\n- `.env.development` - 로컬 개발\n- `.env.staging` - 스테이징 (Amoy)\n- `.env.production` - 프로덕션 (Polygon Mainnet)",
        "testStrategy": "1. Swagger UI에서 모든 API 문서 검토\n2. 운영 가이드 절차 검증 (신규 인력 온보딩 시뮬레이션)\n3. 프로덕션 Docker Compose로 로컬 테스트\n4. Health Check 및 모니터링 정상 동작 확인\n5. 스케일링 절차 테스트\n6. 트러블슈팅 시나리오별 복구 절차 검증",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-15T00:42:34.388Z",
      "updated": "2025-12-15T00:42:34.388Z",
      "description": "Tasks for master context"
    }
  }
}